### 汇编版本

```asm
static inline uint64_t InterlockedCompareExchange64(volatile uint64_t* ptr, uint64_t _new,
                                                    uint64_t old) {
  uint64_t prev;
  asm volatile("lock;"
               "cmpxchgq %1, %2;"
               : "=a"(prev)
               : "q"(_new), "m"(*ptr), "a"(old)
               : "memory");
  return prev;
}
```

### C++版本

```c++
uint64_t CAS(uint64_t* ptr, uint64_t _new, uint64_t old) {
    if (*ptr == old) {
        *ptr = _new;
    } else {
        old = *ptr;
    }
    return old;
}
```

简单的说，就是A、B两个线程都想对某块内存ptr进行+1操作，比如ptr之前是10，+1后则是11。

众所周知，对某个进行加法的操作，实际上不是原子的，总共包含3个步骤：

1）从内存ptr中取10到寄存器；2）在寄存器中+1；3）将结果返还内存覆盖原ptr。

### 所以CAS的目的是什么呢？

其实就是A、B两个线程同时在做这件事的时候，起到“锁”的效果。比如A、B线程都做了1）2）两步，然后A线程更快地做了3），那么此时B线程就不能再做3）了，因为此时ptr已经被A改成了11，如果B线程再做3），无疑是把11又覆盖一遍，导致了2次+1的结果是11。

所以CAS引入了3个参数，ptr就是想要赋值的内存地址，new就是想覆盖的新值，而old是记录原始内存的值。

在做第3）步之前，会进行这个CAS操作，将当前的内存值ptr和原始记录的内存值old进行对比。

如果相等，则说明之前没人动过，可以直接赋值，将new给ptr；返回old，即自己赋值之前的内存值ptr。

否则，说明之前动过了，不能把new给ptr了，而将ptr给old，重新用old记录当前最新的内存值ptr；也返回old，即当前被别人赋值后的新的内存值ptr。

### CAS的ABA问题

ABA问题是CAS的典型问题：即比如还是刚才的例子，A给ptr赋值+1成11了，此时B也完成了2），但还没做操作3），但又来一个C线程抢先了，他直接1）2）3）赶在B的3）之前，把ptr的值又从11改回10了，然后轮到B的3），此时B一判断CAS，发现old=ptr=10（本来没C的话，是old=10，ptr=11），没问题嘛，然后B就执行第3步又把10+1=11了。实际上B这轮CAS是不能做这步操作的，要做至少也应该到下一轮判断CAS重新做。

另外有一个更好理解的例子，小李去ATM取钱，取了50，但ATM机由于BUG把这次50的取款请求提交了2次，本来应该是1次做完了，另一次判断CAS冲突，就不做了（因为发现old=100，ptr=50而不是old=100，ptr=100），结果小李的妈妈突然给小李打了50块转账，然后光速到账了，就导致前面提到的另一次判断时（old=100，ptr=100），没问题嘛，就又给小李扣了50，最终多扣了50，只有小李受伤的世界完成了。

ABA的问题解决：不仅要用ptr=old对比，还要用版本号，比如妈妈转账后，此时版本号就不同了，不能继续扣款。

### 乐观锁&悲观锁

其实CAS就是典型的乐观锁，也是自旋锁，CPU会一直用资源去自旋判断，直到CAS通过为止，默认认为不冲突，直接就去访问修改，如果冲突了再回退。

而我们平时的mutex，就是悲观锁，默认认为冲突，所以先就锁起来，只让1个线程访问。

通常来说，乐观锁性能更好，因为没有线程从运行态到睡眠态再到运行态的切换唤醒之类的时间开销，但显然占用资源、功耗更高。







