# 并发多线程&乐观锁&悲观锁

- 互斥锁、自旋锁、读写锁，都是属于悲观锁。（疑问：自旋锁如果是基于CAS，那他不是乐观锁吗？？？）

悲观锁做事比较悲观，它认为`多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。`

那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。

乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：`先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。`

放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。

可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现`乐观锁全程并没有加锁，所以它也叫无锁编程。`

这里举一个场景例子：在线文档。

我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。

那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。

怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交改动，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。

服务端要怎么验证是否冲突了呢？通常方案如下：

- 由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；
       当用户提交修改时，发给服务端的请求会带上原始文档**版本号**，服务器收到后将它与当前版本号进行比较，如果版本号一致则修改成功，否则提交失败。
- 实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。

乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以`只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。`

### 悲观锁

悲观锁（Pessimistic Lock）： 

- 就是很悲观，每次去拿数据的时候都认为别人会修改。所以每次在拿数据的时候都会上锁。这样别人想拿数据就被挡住，直到悲观锁被释放，悲观锁中的共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。
- 但是在效率方面，处理加锁的机制会产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，如果已经锁定了一个线程A，其他线程就必须等待该线程A处理完才可以处理。

- 数据库中的行锁，表锁，读锁（共享锁），写锁（排他锁），以及syncronized实现的锁均为悲观锁。

- 悲观并发控制实际上是“**先取锁再访问**”的保守策略，为数据处理的安全提供了保证。


![image-20220622203126641](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/image-20220622203126641.png)

### 乐观锁

乐观锁（Optimistic Lock）：

- 就是很乐观，每次去拿数据的时候都认为别人不会修改。所以不会上锁，但是如果想要更新数据，则会在更新前检查在读取至更新这段时间别人有没有修改过这个数据。如果修改过，则重新读取，再次尝试更新，循环上述步骤直到更新成功（当然也允许更新失败的线程放弃操作），乐观锁适用于多读的应用类型，这样可以提高吞吐量。
- 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录**数据版本（version）**或者是**时间戳**来实现，不过使用版本记录是最常用的。

- 乐观控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。


![image-20220622203211195](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/image-20220622203211195.png)

### 参考链接

[(2 封私信 / 80 条消息) 自旋锁 - 搜索结果 - 知乎 (zhihu.com)](https://www.zhihu.com/search?type=content&q=自旋锁)

[(13条消息) 悲观锁与乐观锁的实现(详情图解)_牧小农的博客-CSDN博客_乐观锁和悲观锁的实现](https://blog.csdn.net/qq_14996421/article/details/106351873?ops_request_misc=%7B%22request%5Fid%22%3A%22165578136016782395331927%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=165578136016782395331927&biz_id=0&spm=1018.2226.3001.4187)